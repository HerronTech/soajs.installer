"use strict";
// Copyright 2014-2016, Google, Inc.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
var async = require("async");
var fs = require("fs");
var transporters_1 = require("google-auth-library/lib/transporters");
var minimist = require("minimist");
var mkdirp = require("mkdirp");
var nunjucks = require("nunjucks");
var path = require("path");
var url = require("url");
var util = require("util");
var generator_utils_1 = require("./generator_utils");
var argv = minimist(process.argv.slice(2));
var cliArgs = argv._;
var DISCOVERY_URL = argv['discovery-url'] ?
    argv['discovery-url'] :
    (cliArgs.length ? cliArgs[0] :
        'https://www.googleapis.com/discovery/v1/apis/');
var FRAGMENT_URL = 'https://storage.googleapis.com/apisnippets-staging/public/';
var srcPath = path.join(__dirname, '../../../src');
var TEMPLATES_DIR = path.join(srcPath, 'templates');
var API_TEMPLATE = path.join(TEMPLATES_DIR, 'api-endpoint.njk');
var INDEX_TEMPLATE = path.join(TEMPLATES_DIR, 'index.njk');
var RESERVED_PARAMS = ['resource', 'media', 'auth'];
var Generator = /** @class */ (function () {
    /**
     * Generator for generating API endpoints
     *
     * @private
     * @param {object} options Options for generation
     * @this {Generator}
     */
    function Generator(options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        this.transporter = new transporters_1.DefaultTransporter();
        this.state = {};
        this.options = options;
        /**
         * This API can generate thousands of concurrent HTTP requests.
         * If left to happen while generating all APIs, things get very unstable.
         * This makes sure we only ever have 10 concurrent network requests, and
         * adds retry logic.
         */
        this.requestQueue = async.queue(function (opts, callback) {
            async.retry(3, function () {
                return _this.transporter.request(opts, callback);
            });
        }, 10);
        this.env = new nunjucks.Environment(new nunjucks.FileSystemLoader(TEMPLATES_DIR), { trimBlocks: true });
        this.env.addFilter('buildurl', generator_utils_1.buildurl);
        this.env.addFilter('oneLine', this.oneLine);
        this.env.addFilter('cleanComments', this.cleanComments);
        this.env.addFilter('getPathParams', this.getPathParams);
        this.env.addFilter('getSafeParamName', this.getSafeParamName);
        this.env.addFilter('cleanPaths', function (str) {
            return str ? str.replace(/\/\*\//gi, '/x/').replace(/\/\*`/gi, '/x') : '';
        });
    }
    /**
     * A multi-line string is turned into one line.
     *
     * @private
     * @param  {string} str String to process
     * @return {string}     Single line string processed
     */
    Generator.prototype.oneLine = function (str) {
        return str ? str.replace(/\n/g, ' ') : '';
    };
    /**
     * Clean a string of comment tags.
     *
     * @private
     * @param  {string} str String to process
     * @return {string}     Single line string processed
     */
    Generator.prototype.cleanComments = function (str) {
        // Convert /* into /x and */ into x/
        return str ? str.replace(/\*\//g, 'x/').replace(/\/\*/g, '/x') : '';
    };
    Generator.prototype.getPathParams = function (params) {
        var pathParams = [];
        if (typeof params !== 'object') {
            params = {};
        }
        Object.keys(params).forEach(function (key) {
            if (params[key].location === 'path') {
                pathParams.push(key);
            }
        });
        return pathParams;
    };
    Generator.prototype.getSafeParamName = function (param) {
        if (RESERVED_PARAMS.indexOf(param) !== -1) {
            return param + '_';
        }
        return param;
    };
    /**
     * Add a requests to the rate limited queue.
     * @param opts Options to pass to the default transporter
     * @param callback
     */
    Generator.prototype.makeRequest = function (opts, callback) {
        this.requestQueue.push(opts, callback);
    };
    /**
     * Log output of generator
     * Works just like console.log
     */
    Generator.prototype.log = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (this.options && this.options.debug) {
            console.log.apply(this, arguments);
        }
    };
    /**
     * Write to the state log, which is used for debugging.
     * @param id DiscoveryRestUrl of the endpoint to log
     * @param message
     */
    Generator.prototype.logResult = function (id, message) {
        if (!this.state[id]) {
            this.state[id] = [];
        }
        this.state[id].push(message);
    };
    /**
     * Generate all APIs and write to files.
     *
     * @param {function} callback Callback when all APIs have been generated
     * @throws {Error} If there is an error generating any of the APIs
     */
    Generator.prototype.generateAllAPIs = function (callback) {
        var _this = this;
        var headers = this.options.includePrivate ? {} : { 'X-User-Ip': '0.0.0.0' };
        this.makeRequest({ uri: DISCOVERY_URL, headers: headers }, function (err, resp) {
            if (err) {
                return generator_utils_1.handleError(err, callback);
            }
            var apis = resp.items;
            var queue = async.queue(function (api, next) {
                _this.log('Generating API for %s...', api.id);
                _this.logResult(api.discoveryRestUrl, 'Attempting first generateAPI call...');
                async.retry(3, _this.generateAPI.bind(_this, api.discoveryRestUrl), function (e, results) {
                    if (e) {
                        _this.logResult(api.discoveryRestUrl, "GenerateAPI call failed with error: " + e + ", moving on.");
                        console.error("Failed to generate API: " + api.id);
                        console.log(api.id + '\n-----------\n' +
                            util.inspect(_this.state[api.discoveryRestUrl], { maxArrayLength: null }) +
                            '\n');
                    }
                    else {
                        _this.logResult(api.discoveryRestUrl, "GenerateAPI call success!");
                    }
                    _this.state[api.discoveryRestUrl].done = true;
                    next(e, results);
                });
            }, 3);
            apis.forEach(function (api) {
                queue.push(api);
            });
            queue.drain = function (drainError) {
                console.log(util.inspect(_this.state, { maxArrayLength: null }));
                if (drainError && callback) {
                    callback(drainError);
                    return;
                }
                _this.generateIndex(callback);
            };
        });
    };
    Generator.prototype.generateIndex = function (callback) {
        var apis = {};
        var apisPath = path.join(srcPath, 'apis');
        var indexPath = path.join(apisPath, 'index.ts');
        // Dynamically discover available APIs
        fs.readdirSync(apisPath).forEach(function (file) {
            var filePath = path.join(apisPath, file);
            if (!fs.statSync(filePath).isDirectory()) {
                return;
            }
            apis[file] = {};
            fs.readdirSync(path.join(apisPath, file)).forEach(function (version) {
                var parts = path.parse(version);
                if (!version.endsWith('.d.ts') && parts.ext === '.ts') {
                    apis[file][version] = parts.name;
                }
            });
        });
        var result = this.env.render('index.njk', { apis: apis });
        fs.writeFile(indexPath, result, { encoding: 'utf8' }, function (err) {
            if (callback)
                callback(err);
        });
    };
    /**
     * Given a discovery doc, parse it and recursively iterate over the various
     * embedded links.
     * @param api
     * @param schema
     * @param apiPath
     * @param tasks
     */
    Generator.prototype.getFragmentsForSchema = function (apiDiscoveryUrl, schema, apiPath, tasks) {
        var _this = this;
        if (schema.methods) {
            var _loop_1 = function (methodName) {
                if (schema.methods.hasOwnProperty(methodName)) {
                    var methodSchema_1 = schema.methods[methodName];
                    methodSchema_1.sampleUrl = apiPath + '.' + methodName + '.frag.json';
                    tasks.push(function (cb) {
                        _this.logResult(apiDiscoveryUrl, "Making fragment request...");
                        _this.logResult(apiDiscoveryUrl, methodSchema_1.sampleUrl);
                        _this.makeRequest({ uri: methodSchema_1.sampleUrl }, function (err, response) {
                            if (err) {
                                _this.logResult(apiDiscoveryUrl, "Fragment request err: " + err);
                                if (!err.message ||
                                    err.message.indexOf('AccessDenied') === -1) {
                                    return cb(err);
                                }
                                else {
                                    _this.logResult(apiDiscoveryUrl, 'Ignoring error.');
                                }
                            }
                            _this.logResult(apiDiscoveryUrl, "Fragment request complete.");
                            if (response && response.codeFragment &&
                                response.codeFragment['Node.js']) {
                                var fragment = response.codeFragment['Node.js'].fragment;
                                fragment = fragment.replace(/\/\*/gi, '/<');
                                fragment = fragment.replace(/\*\//gi, '>/');
                                fragment = fragment.replace(/`\*/gi, '`<');
                                fragment = fragment.replace(/\*`/gi, '>`');
                                var lines_1 = fragment.split('\n');
                                lines_1.forEach(function (line, i) {
                                    lines_1[i] = '*' + (line ? ' ' + lines_1[i] : '');
                                });
                                fragment = lines_1.join('\n');
                                methodSchema_1.fragment = fragment;
                            }
                            cb();
                        });
                    });
                }
            };
            for (var methodName in schema.methods) {
                _loop_1(methodName);
            }
        }
        if (schema.resources) {
            for (var resourceName in schema.resources) {
                if (schema.resources.hasOwnProperty(resourceName)) {
                    this.getFragmentsForSchema(apiDiscoveryUrl, schema.resources[resourceName], apiPath + '.' + resourceName, tasks);
                }
            }
        }
    };
    /**
     * Generate API file given discovery URL
     * @param  {String} apiDiscoveryUri URL or filename of discovery doc for API
     * @param {function} callback Callback when successful write of API
     * @throws {Error} If there is an error generating the API.
     */
    Generator.prototype.generateAPI = function (apiDiscoveryUrl, callback) {
        var _this = this;
        var generate = function (err, resp) {
            _this.logResult(apiDiscoveryUrl, "Discovery doc request complete.");
            if (err) {
                generator_utils_1.handleError(err, callback);
                return;
            }
            var tasks = [];
            _this.getFragmentsForSchema(apiDiscoveryUrl, resp, FRAGMENT_URL + resp.name + '/' + resp.version + '/0/' + resp.name, tasks);
            // e.g. apis/drive/v2.js
            var exportFilename = path.join(srcPath, 'apis', resp.name, resp.version + '.ts');
            var contents;
            _this.logResult(apiDiscoveryUrl, "Generating templates...");
            async.waterfall([
                function (cb) {
                    _this.logResult(apiDiscoveryUrl, "Step 1...");
                    async.parallel(tasks, cb);
                },
                function (results, cb) {
                    _this.logResult(apiDiscoveryUrl, "Step 2...");
                    contents = _this.env.render(API_TEMPLATE, { api: resp });
                    mkdirp(path.dirname(exportFilename), cb);
                },
                function (dir, cb) {
                    _this.logResult(apiDiscoveryUrl, "Step 3...");
                    fs.writeFile(exportFilename, contents, { encoding: 'utf8' }, cb);
                }
            ], function (e) {
                if (e) {
                    generator_utils_1.handleError(e, callback);
                    return;
                }
                _this.logResult(apiDiscoveryUrl, "Template generation complete.");
                callback(null, exportFilename);
            });
        };
        var parts = url.parse(apiDiscoveryUrl);
        if (apiDiscoveryUrl && !parts.protocol) {
            this.log('Reading from file ' + apiDiscoveryUrl);
            try {
                return generate(null, JSON.parse(fs.readFileSync(apiDiscoveryUrl, { encoding: 'utf-8' })));
            }
            catch (err) {
                return generator_utils_1.handleError(err, callback);
            }
        }
        else {
            this.logResult(apiDiscoveryUrl, "Starting discovery doc request...");
            this.logResult(apiDiscoveryUrl, apiDiscoveryUrl);
            this.makeRequest({ uri: apiDiscoveryUrl }, generate);
        }
    };
    return Generator;
}());
exports.Generator = Generator;
//# sourceMappingURL=generator.js.map